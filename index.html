<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circuit Maker</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }

    h1 {
      color: #333;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="1200" height="1000"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"></script>
  <script>
    let counter = 0;
    let connecting = false;
    let connectingLine = null;
    let connectingfrom = null;
    let connectingto = null;
    let selectedComponent = null;

    function setUpImage(img) {
      img.set({
        left:50,
        dirty: true,
        scaleX: 0.4,
        scaleY: 0.4,
        originX: 'center',
        originY: 'center',
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        id: counter,
        connectionPositions: [0,45,0],
        positionOfRottaion: 0,
        lines1: [],
        lines2: [],

      });
      switch(img.name){
        case 'Light Bulb':
          img.top = 150;
          break;
        case 'Resistor':
          img.top = 250;
          break;
        case 'Source':
          img.top = 350;
          break;
      }
      
      img.on('moving', function (options) {
        hideButtons();
        //https://jsfiddle.net/fabricjs/S9sLu
        if(img.left>200 && img.left<1200 && img.top>0 && img.top<1000){
          
        let grid = 100;
        img.set({
          left: Math.round(img.left / grid) * grid,
          top: Math.round(img.top / grid) * grid,
        });
        updateConnectionPositions(img);
        }

      });

      img.on('mouseup', function () {
        console.log('Image double-clicked:', img);
        selectedComponent = img;
        showButtons(img);
        
        
      });
      img.on('selected', function (options) {
        if (!connecting) {

        } else {
          let pointer = canvas.getPointer(options.e);
          console.log('Pointer left:', pointer.x, 'Pointer top:', pointer.y);
          let pointerPosition, componentPosition;
          if(img.connectionPositions[0] %2==1){
            console.log('Vertical component selected');
             pointerPosition = pointer.y;
            componentPosition = img.top;
          }else{
            console.log('Horizontal component selected');
            pointerPosition = pointer.x;
            componentPosition = img.left;
          }
          if(img.connectionPositions[0] >1){
            pointerPosition *=-1;
            componentPosition *=-1;
          }
          
          if(pointerPosition>componentPosition){
            connectingto = "plus";
          }else{
            connectingto = "minus";
          }
          stopConnecting(img);
        }
      });
      canvas.add(img);
     
    }

    const canvas = new fabric.Canvas('canvas');
    canvas.on('mouse:down', function (options) {
      console.log('Canvas mouse down:', options);
      if (options.target == null) {
        hideButtons();
        console.log('Clicked on empty canvas area, hiding buttons.');
        if(connecting){
          stopConnecting(null);
        }
      }else{
        console.log('Clicked on object:', options.target);
      }
    });
    canvas.backgroundColor = 'rgb(48, 87, 225)';
    canvas.preserveObjectStacking = true;
    canvas.renderAll();
    canvas.selection = false;
    for (let i = 1; i < 13; i++) {
      const lineX = new fabric.Line([200, i * 100 - 50, 1200, i * 100 - 50], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',


      });
      lineX.set({
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
      });
      /*
      const lineHalfX = new fabric.Line([0, i * 50 + 100, 1200, i * 50 + 100], {
        stroke: 'white',
        strokeWidth: 0.5,
        selectable: false,
      });
      */
      const lineY = new fabric.Line([i * 100 - 50, 0, i * 100 - 50, 1000], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',
      });
      /*
      const lineHalfY = new fabric.Line([i * 50 + 100, 0, i * 50 + 100, 1000], {
        stroke: 'white',
        strokeWidth: 0.5,
        selectable: false,

      });
      */
      canvas.sendObjectToBack(lineX);
      canvas.sendObjectToBack(lineY);

      canvas.add(lineX);
      //canvas.add(lineHalfX);
      canvas.add(lineY);
      canvas.requestRenderAll();
      //canvas.add(lineHalfY);
    }
    
    var text = new fabric.Textbox('Hello World', {
      left: 150,
      top: 100,
      fontSize: 40,
      fill: 'white',
      originX: 'center',
      originY: 'center',
    });
    var plus_button = new fabric.Text('+', {
      left: 150,
      top: 150,
      fontSize: 50,

      originX: 'center',
      originY: 'center',
    });
    var minus_button = new fabric.Text('-', {
      left: 150,
      top: 200,
      fontSize: 50,

      originX: 'center',
      originY: 'center',
    });
    var delete_button = new fabric.Text('Delete', {
      left: 150,
      top: 250,
      fontSize: 50,

      originX: 'center',
      originY: 'center',
    });
    var rotate_button = new fabric.Text('Rotate', {
      left: 150,
      top: 300,
      fontSize: 50,

      originX: 'center',
      originY: 'center',
    });
    plus_button.on('mousedown', function () {
      connectingfrom = "plus";
      startConnecting(selectedComponent);
    });
    minus_button.on('mousedown', function () {
      connectingfrom = "minus";
      startConnecting(selectedComponent);
    });
    delete_button.on('mousedown', function () {
      deleteComponent(selectedComponent.id);
    });
    rotate_button.on('mousedown', function () {
      rotateComponent(selectedComponent);
    });
    buttonSetUp(text);
    buttonSetUp(plus_button);
    buttonSetUp(minus_button);
    buttonSetUp(delete_button);
    buttonSetUp(rotate_button);

    function showButtons(image) {
      selectedComponent = image;
      text.set({
        text: image.name,
        left: image.left,
        top: image.top - 75, // Position text above the image
        

      });
      plus_button.set({
        text: '+',
        left: image.left + 75,
        top: image.top, // Position text above the image
      });
      minus_button.set({
        left: image.left - 75,
        top: image.top, // Position text above the image
        

      });
      delete_button.set({
        left: image.left,
        top: image.top + 75, // Position text above the image
       

      });
      rotate_button.set({
        left: image.left,
        top: image.top + 150, // Position text above the image
        

      });
      text.set('visible', true);
      plus_button.set('visible', true);
      minus_button.set('visible', true);
      delete_button.set('visible', true);
      rotate_button.set('visible', true);
      text.setCoords();
      plus_button.setCoords();
      minus_button.setCoords();
      delete_button.setCoords();
      rotate_button.setCoords();

      canvas.bringObjectToFront(text);
      canvas.bringObjectToFront(plus_button);
      canvas.bringObjectToFront(minus_button);
      canvas.bringObjectToFront(delete_button);
      canvas.bringObjectToFront(rotate_button);

      text.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);
      canvas.requestRenderAll();
    }
    function hideButtons() {
      text.set('visible', false);
      plus_button.set('visible', false);
      minus_button.set('visible', false);
      delete_button.set('visible', false);
      rotate_button.set('visible', false);
      text.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);

      text.set({
        left: -1000,
        top: -100,
      });
      plus_button.set({
        left: -1000,
        top: -100,
      });
      minus_button.set({
        left: -1000,
        top: -100,
      });
      delete_button.set({
        left: -1000,
        top: -100,
      });
      rotate_button.set({
        left: -1000,
        top: -100,
      });

      canvas.requestRenderAll();
    }
    function buttonSetUp(button) {
      button.set({
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        selectable: true,
        lockMovementX: true,
        lockMovementY: true,
        dirty: true,
        fill: 'red',
      });

    }
    function addComponent(url, name) {
      fabric.Image.fromURL(url).then((img) => {
        img.set({
          name: name,
        });
        setUpImage(img);
        
        //img.visible = false;
        return img;
      });
    }
    function deleteComponent(id) {
      const obj = canvas.getObjects().find(o => o.id === id);
      if (obj) {
        canvas.remove(obj);
        hideButtons();
      }
    }
    function rotateComponent(component) {
      console.log('Rotating component:', component);
      component.rotate((component.angle + 90) % 360);
      component.set('dirty', true);
      component.set({
        positionOfRottaion: component.positionOfRottaion + 1,
      });
      if (component.positionOfRottaion === 4) {
        component.positionOfRottaion = 0;
      }
      switch (component.connectionPositions[0]) {
        case 0:
          component.connectionPositions = [1,0,45];
          break;
        case 1:
          component.connectionPositions = [2,-45,0];
          break;
        case 2:
          component.connectionPositions = [3,0,-45];
          break;
        case 3:
          component.connectionPositions = [0,45,0];
          break;
      }
      updateConnectionPositions(component);


      canvas.requestRenderAll();
    }
    function connectComponents(component1, component2) {
  
     let x1,y1,x2,y2;
     if(connectingfrom === "plus"){
        x1=component1.connectionPositions[1];
        y1=component1.connectionPositions[2];
      }else{
        x1=-component1.connectionPositions[1];
        y1=-component1.connectionPositions[2];
      }
      if(connectingto === "plus"){
        x2=component2.connectionPositions[1];
        y2=component2.connectionPositions[2];
      }else{
        x2=-component2.connectionPositions[1];
        y2=-component2.connectionPositions[2];
      }

      const line = new fabric.Line([component1.left + x1, component1.top + y1, component2.left + x2, component2.top + y2], {
        stroke: 'gray',
        strokeWidth: 4,
        selectable: false,
        positionLeft1:x1,
        positionTop1:y1,
        positionLeft2:x2,
        positionTop2:y2,
        connectedFrom: connectingfrom,
        connectedTo: connectingto,
      });
      connectingfrom = null;
      connectingto = null;
      component1.lines1.push(line);
      component2.lines2.push(line);
      canvas.add(line);

      canvas.sendObjectToBack(line);
      canvas.requestRenderAll();
    }
    function disconnectComponents(line) {
      canvas.remove(line);
      canvas.requestRenderAll();
    }
    function startConnecting(component) {
      connecting = true;
      selectedComponent = component;
      connectingLine = new fabric.Line([component.left, component.top, component.left, component.top], {
        stroke: 'red',
        strokeWidth: 2,
        selectable: false,
      });
      canvas.add(connectingLine);
      canvas.on('mouse:move', function (options) {
        if (connecting) {
          connectingLine.set({ x2: options.pointer.x, y2: options.pointer.y });
          canvas.requestRenderAll();
        }
      });

    }
    function stopConnecting(component) {

      
      if(component!=null){
      connectComponents(selectedComponent, component);
      canvas.off('mouse:move');
     
    }
    connecting = false;
     if (connectingLine) {
        canvas.remove(connectingLine);
        connectingLine = null;
        canvas.requestRenderAll();
      }
    }
    function getConnectionPositions(component) {
      let positions = [];
      switch (component.positionOfRottaion) {
        case 0:
          positions.push({ x: component.left + 45, y: component.top });
          positions.push({ x: component.left - 45, y: component.top });
          break;
        case 1:
          positions.push({ x: component.left, y: component.top - 45 });
          positions.push({ x: component.left, y: component.top + 45 });
          break;
        case 2:
          positions.push({ x: component.left - 45, y: component.top });
          positions.push({ x: component.left + 45, y: component.top });
          break;
        case 3:
          positions.push({ x: component.left, y: component.top + 45 });
          positions.push({ x: component.left, y: component.top - 45 });
          break;
      }
      return positions;
    }
    function updateConnectionPositions(component) {
    const posX = component.connectionPositions[1]; 
    const posY = component.connectionPositions[2]; 

    component.lines1.forEach((line, index) => {
      if(line.connectedFrom === "plus"){
        line.set({
          x1: component.left+ posX,
          y1: component.top + posY,
        });
      }else{
        line.set({
          x1: component.left - posX,
          y1: component.top - posY,
        });
      }
      line.setCoords();
    });
    component.lines2.forEach((line, index) => {
      if(line.connectedTo === "plus"){
        line.set({
          x2: component.left + posX,
          y2: component.top + posY,
        });
      }else{
        line.set({
          x2: component.left - posX,
          y2: component.top - posY,
        });
      }
      line.setCoords();
    });

    canvas.requestRenderAll();
}

    canvas.add(text);
    canvas.add(plus_button);
    canvas.add(minus_button);
    canvas.add(delete_button);
    canvas.add(rotate_button);

    const rectangle = new fabric.Rect({
      left: 0,
      top: 0,
      fill: 'black',
      width: 200,
      height: 1000,
      selectable: false,
      evented: false,
    });
    canvas.add(rectangle);
    var bulb = addComponent('./images/light_bulb.png', 'Light Bulb');
    var resistor = addComponent('./images/resistor.png', 'Resistor');
    var source = addComponent('./images/source.png', 'Source');
    var source2 = addComponent('./images/source.png', 'Source');

  </script>
</body>

</html>

