<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Circuit Maker</title>
<style>
  body {
      margin: 0;
      padding:0;
      font-family: Arial, sans-serif;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .fabric-canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
      touch-action: none; 
    }

    #canvas {

      display: block;
    }

    header {
      background-color: #333;
      color: white;
      padding: 1px;
      text-align: center;
    }

    .main-content {
      display: flex;
      flex: 1;
    }

    .sidebar {
      background-color: #f9f9f9;
      border-right: 1px solid #ddd;
      padding: 15px;
      width: 150px;
      height: 80vh;
      overflow-y: auto;
    }

    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        height: auto;
        border-right: none;
        border-bottom: 1px solid #ddd;
      }

      .main-content {
        flex-direction: column;
      }

      main {
        width: 100%;
      }
    }

    .sidebar h2 {
      margin-top: 0;
      color: #333;
    }

    .sidebar button {
      display: block;
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .sidebar button:hover {
      background-color: #0056b3;
    }

    main {
      flex: 1;
      overflow: hidden;
    }

    #canvas {
      display: block;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Circuit Maker</h1>
    </header>
    <div class="main-content">
      <aside class="sidebar">
        <h2>Components</h2>
        <button onclick="addComponent('./images/light_bulb.png', 'Light Bulb')">Add Light Bulb</button>
        <button onclick="addComponent('./images/resistor.png', 'Resistor')">Add Resistor</button>
        <button onclick="addComponent('./images/source.png', 'Source')">Add Source</button>
      </aside>
      <main>
        <div class="fabric-canvas-container" id="fabric-canvas-container">
          <canvas id="canvas" width="1400" height="1000"></canvas>
        </div>
      </main>
    </div>
  </div>

  

  <script src="https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"></script>
  <script>

    let counter = 0;
    let connecting = false;
    let connectingLine = null;
    let connectingfrom = null;
    let connectingto = null;
    let allLines = [];
    let selectedComponent = null;
    let bottom = 0;




    const canvasGrid = [];
    for (let i = 0; i < 9; i += 1) {
      canvasGrid.push(new Array(9).fill(null));
    }
    canvasGrid.forEach(row => {
      console.log(row);
    });






    function setUpImage(img) {
      let color = [Math.random() * 256, Math.random() * 256, Math.random() * 256];

      img.set({
        left: 50,
        dirty: true,
        scaleX: 0.4,
        scaleY: 0.4,
        originX: 'center',
        originY: 'center',
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        id: counter,
        connectionPositions: [0, 45, 0],
        positionOfRottaion: 0,
        lines1: [],
        lines2: [],
        lineColor: color,
        gridPositionX: null,
        gridPositionY: null,
        startX: null,
        startY: null,

      });
      canvas.moveObjectTo(img, bottom);
      switch (img.name) {
        case 'Light Bulb':
          img.top = 150;
          break;
        case 'Resistor':
          img.top = 250;
          break;
        case 'Source':
          img.top = 350;
          break;
        case 'Switch':
          img.top = 450;
          break;
      }
      img.on('mousedown', function (options) {
        img.startX = img.gridPositionX;
        img.startY = img.gridPositionY;
      });
      img.on('moving', function (options) {
        hideButtons();
        //https://jsfiddle.net/fabricjs/S9sLu
        let grid = 100;
        if (img.left > 200 && img.left < 1200 && img.top > 0 && img.top < 1000) {
          //console.log("left:" + Math.round(img.left / grid) + " top:" + Math.round(img.top / grid));

          /*img.set({
            left: Math.round(img.left / grid) * grid,
            top: Math.round(img.top / grid) * grid,
          });*/
          let gridX = Math.round(img.left / grid) - 3;
          let gridY = Math.round(img.top / grid) - 1;
          if (gridY >= 0 && gridY < 9 && gridX >= 0 && gridX < 9 && (canvasGrid[gridY][gridX] == null || canvasGrid[gridY][gridX] === img)) {
            // console.log("moving to grid");


            img.left = Math.round(img.left / grid) * grid;
            img.top = Math.round(img.top / grid) * grid;
            img.gridPositionX = gridX;
            img.gridPositionY = gridY;
            img.setCoords();


          }

        }
        updateConnectionPositions(img);
      });

      img.on('mouseup', function () {
        
        if (img.startX != null && img.startY != null) {
          canvasGrid[img.startY][img.startX] = null;
        }

        if (img.left > 1200) {

          deleteComponent(img);
          return;
        } else if (img.left < 200) {

          img.gridPositionX = null;
          img.gridPositionY = null;
          img.lines1.forEach((line, index) => {
            disconnectComponents(line);
          });
          img.lines2.forEach((line, index) => {
            disconnectComponents(line);
          });
          return;
        }

        if (img.gridPositionX != null && img.gridPositionY != null) {
          canvasGrid[img.gridPositionY][img.gridPositionX] = img;
        }

        img.set({
          left: img.gridPositionX * 100 + 300,
          top: img.gridPositionY * 100 + 100,
        });
        img.setCoords();
        canvas.requestRenderAll();
        /*
        canvasGrid.forEach(row => {
          console.log(row);
        });*/
        console.log('Image mouse up:', img);
        selectedComponent = img;
        showButtons(img);


      });
      img.on('selected', function (options) {
        if (!connecting) {
          /* console.log('Image selected:', img);
           selectedComponent = img;
           showButtons(img);*/

        } else {
          let pointer = canvas.getPointer(options.e);
          console.log('Pointer left:', pointer.x, 'Pointer top:', pointer.y);
          let pointerPosition, componentPosition;
          if (img.connectionPositions[0] % 2 == 1) {
            console.log('Vertical component selected');
            pointerPosition = pointer.y;
            componentPosition = img.top;
          } else {
            console.log('Horizontal component selected');
            pointerPosition = pointer.x;
            componentPosition = img.left;
          }
          if (img.connectionPositions[0] > 1) {
            pointerPosition *= -1;
            componentPosition *= -1;
          }

          if (pointerPosition > componentPosition) {
            connectingto = "plus";
          } else {
            connectingto = "minus";
          }
          stopConnecting(img);
        }
      });
      canvas.add(img);

    }

    const canvas = new fabric.Canvas('canvas');
    canvas.on('mouse:down', function (options) {

      //console.log('Canvas mouse down:', options);
      if (options.target == null) {
        hideButtons();
        //console.log('Clicked on empty canvas area, hiding buttons.');
        if (connecting) {
          stopConnecting(null);
        }
      } else {
        console.log('Clicked on object:', options.target);
      }
    });
    canvas.on('mouse:up', function (options) {
      console.log('Canvas mouse up:');
      if (connecting) {
        console.log('Currently connecting, checking if we clicked on a valid target...');
        let pointer = canvas.getPointer(options.e);
        canvas.getObjects().forEach(obj => {
          if (obj.name && obj!==selectedComponent) {
            if(obj.containsPoint(pointer)){
              if(connecting){
                console.log('Clicked on object while connecting:', obj);
                stopConnecting(obj);
                connecting = false;
              }
              
            }
           
          }
        });
        
      }
    });
    canvas.backgroundColor = 'rgb(48, 87, 225)';
    canvas.preserveObjectStacking = true;
   

    canvas.selection = false;
    for (let i = 1; i < 13; i++) {
      const lineX = new fabric.Line([200, i * 100 - 50, 1200, i * 100 - 50], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',


      });
      lineX.set({
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
      });
      

      const lineY = new fabric.Line([i * 100 - 50, 0, i * 100 - 50, 1000], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',
      });
      canvas.add(lineX);
      canvas.add(lineY);
      canvas.sendObjectToBack(lineX);
      canvas.sendObjectToBack(lineY);
      bottom+=2;

      canvas.requestRenderAll();

    }
     const rectangle = new fabric.Rect({
      left: 0,
      top: 0,
      fill: 'white',
      width: 200,
      height: 1000,
      selectable: false,
      evented: false,
    });
    const removeComponentRectangle = new fabric.Rect({
      left: 1200,
      top: 0,
      fill: 'red',
      width: 200,
      height: 1000,
      selectable: false,
      evented: false,
    });
    canvas.add(rectangle);
    canvas.add(removeComponentRectangle);
    canvas.moveObjectTo(rectangle, bottom);

    canvas.moveObjectTo(removeComponentRectangle, bottom);
   
    canvas.renderAll();

    var text = new fabric.Text('hiÅ¯akjfghlak', {
      left: 150,
      top: 100,
      fontSize: 150,
      fill: 'black',
      originX: 'center',
      originY: 'center',
      width: 1000,
      scaleX: 0.2,
      scaleY: 0.2,
    });
    var text_holder;
    fabric.Image.fromURL('./images/text_holder.png').then((img) => {
      img.set({
        left: 100,
        top: 100,
        originX: 'center',
        originY: 'center',
        scaleX: 0.2,
        scaleY: 0.2,
      });

      canvas.add(img);
      canvas.moveObjectTo(img, bottom);
  
      canvas.moveObjectTo(text, bottom);
      

      text_holder = img;
      img.set('visible', false);
      return img;
    });
    var plus_button;
    fabric.Image.fromURL('./images/plus_button.png').then((img) => {
      img.set({
        left: 150,
        top: 150,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      plus_button = img;
      canvas.add(plus_button);
      buttonSetUp(plus_button);
      plus_button.on('mousedown', function (options) {
        connectingfrom = "plus";
        hideButtons();
        startConnecting(selectedComponent);
      });
      return img;
    });
    var minus_button;
    fabric.Image.fromURL('./images/minus_button.png').then((img) => {
      img.set({
        left: 150,
        top: 200,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      minus_button = img;
      canvas.add(minus_button);
      buttonSetUp(minus_button);
      minus_button.on('mousedown', function (options) {
        connectingfrom = "minus";
        hideButtons();
        startConnecting(selectedComponent);
      });
      return img;
    });
    var delete_button;
    fabric.Image.fromURL('./images/delete_button.png').then((img) => {
      img.set({
        left: 150,
        top: 250,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      delete_button = img;
      canvas.add(delete_button);
      buttonSetUp(delete_button);
      delete_button.on('mousedown', function (options) {
        deleteComponent(selectedComponent);
      });
      return img;
    });
    var rotate_button;
    fabric.Image.fromURL('./images/rotate_button.png').then((img) => {
      img.set({
        left: 150,
        top: 300,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      rotate_button = img;
      canvas.add(rotate_button);
      buttonSetUp(rotate_button);
      rotate_button.on('mousedown', function (options) {
        rotateComponent(selectedComponent);
      });
      return img;
    });

    canvas.add(text);

    buttonSetUp(text);


    function showButtons(image) {
      selectedComponent = image;
      text.set({
        text: image.name,
        left: image.left,
        top: image.top - 70,
        stroke: 'black',
        originX: 'center',
        originY: 'center',
      });

      text_holder.set({
        left: image.left,
        top: image.top - 70,
        originX: 'center',
        originY: 'center',
      });

      plus_button.set({

        left: image.left + 80,
        top: image.top,
      });

      minus_button.set({
        left: image.left - 80,
        top: image.top, // Position text above the image


      });
      delete_button.set({
        left: image.left - 40,
        top: image.top + 80, // Position text above the image


      });
      rotate_button.set({
        left: image.left + 40,
        top: image.top + 80, // Position text above the image


      });
      text.set('visible', true);
      text_holder.set('visible', true);
      plus_button.set('visible', true);
      minus_button.set('visible', true);
      delete_button.set('visible', true);
      rotate_button.set('visible', true);
      text.setCoords();
      plus_button.setCoords();
      minus_button.setCoords();
      delete_button.setCoords();
      rotate_button.setCoords();


      canvas.bringObjectToFront(text_holder);
      canvas.bringObjectToFront(text);
      canvas.bringObjectToFront(plus_button);
      canvas.bringObjectToFront(minus_button);
      canvas.bringObjectToFront(delete_button);
      canvas.bringObjectToFront(rotate_button);

      text.set('dirty', true);
      text_holder.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);
      canvas.requestRenderAll();
    }
    function hideButtons() {
      text.set('visible', false);
      text_holder.set('visible', false);
      plus_button.set('visible', false);
      minus_button.set('visible', false);
      delete_button.set('visible', false);
      rotate_button.set('visible', false);

      text.set('dirty', true);
      text_holder.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);


      canvas.requestRenderAll();
    }
    function buttonSetUp(button) {
      button.set({
        left: -1000,
        top: -100,
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        selectable: true,
        lockMovementX: true,
        lockMovementY: true,
        dirty: true,
        fill: 'black',
      });

    }
    function addComponent(url, name) {
      fabric.Image.fromURL(url).then((img) => {
        img.set({
          name: name,
        });
        setUpImage(img);

        //img.visible = false;
        return img;
      });
    }
    function deleteComponent(component) {
      for (let i = component.lines1.length - 1; i >= 0; i--) {
        disconnectComponents(component.lines1[i]);
      }
      for (let i = component.lines2.length - 1; i >= 0; i--) {
        disconnectComponents(component.lines2[i]);
      }

      canvas.remove(component);
      canvasGrid[component.gridPositionY][component.gridPositionX] = null;
      hideButtons();
      canvas.requestRenderAll();

    }
    function deleteLine(line) {
      canvas.remove(line);
      canvas.requestRenderAll();
    }
    function rotateComponent(component) {
      console.log('Rotating component:', component);
      component.rotate((component.angle + 90) % 360);
      component.set('dirty', true);
      component.set({
        positionOfRottaion: component.positionOfRottaion + 1,
      });
      if (component.positionOfRottaion === 4) {
        component.positionOfRottaion = 0;
      }
      switch (component.connectionPositions[0]) {
        case 0:
          component.connectionPositions = [1, 0, 45];
          break;
        case 1:
          component.connectionPositions = [2, -45, 0];
          break;
        case 2:
          component.connectionPositions = [3, 0, -45];
          break;
        case 3:
          component.connectionPositions = [0, 45, 0];
          break;
      }
      updateConnectionPositions(component);


      canvas.requestRenderAll();
    }
    function connectComponents(component1, component2) {

      let x1, y1, x2, y2;
      if (connectingfrom === "plus") {
        x1 = component1.connectionPositions[1];
        y1 = component1.connectionPositions[2];
      } else {
        x1 = -component1.connectionPositions[1];
        y1 = -component1.connectionPositions[2];
      }
      if (connectingto === "plus") {
        x2 = component2.connectionPositions[1];
        y2 = component2.connectionPositions[2];
      } else {
        x2 = -component2.connectionPositions[1];
        y2 = -component2.connectionPositions[2];
      }
      let strokeColor = component1.lineColor;
      const line = new fabric.Line([component1.left + x1, component1.top + y1, component2.left + x2, component2.top + y2], {
        stroke: `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`,
        strokeWidth: 4,
        selectable: false,
        positionLeft1: x1,
        positionTop1: y1,
        positionLeft2: x2,
        positionTop2: y2,
        connectedFrom: connectingfrom,
        connectedFromComponent: component1,
        connectedTo: connectingto,
        connectedToComponent: component2,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });
      connectingfrom = null;
      connectingto = null;
      component1.lines1.push(line);
      component2.lines2.push(line);
      allLines.push(line);
      canvas.add(line);

      canvas.moveObjectTo(line, bottom);
      canvas.requestRenderAll();
    }
    function disconnectComponents(line) {
      line.connectedFromComponent.lines1.splice(line.connectedFromComponent.lines1.indexOf(line), 1);
      line.connectedToComponent.lines2.splice(line.connectedToComponent.lines2.indexOf(line), 1);
      allLines.splice(allLines.indexOf(line), 1);
      canvas.remove(line);
      canvas.requestRenderAll();
    }
    function startConnecting(component) {
      connecting = true;
      selectedComponent = component;
      strokeColor = component.lineColor;
      let multiplier = 1;
      if (connectingfrom === "minus") {
        multiplier = -1;
      }
      connectingLine = new fabric.Line([component.left + component.connectionPositions[1] * multiplier, component.top + component.connectionPositions[2] * multiplier, component.left, component.top], {
        stroke: `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`,
        strokeWidth: 4,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });
      canvas.add(connectingLine);
      canvas.on('mouse:move', function (options) {
        if (connecting) {
          let pointer = canvas.getPointer(options.e);
          connectingLine.set({ x2: pointer.x, y2: pointer.y });
          canvas.requestRenderAll();
        }
      });

    }
    function stopConnecting(component) {


      if (component != null) {
        connectComponents(selectedComponent, component);
        canvas.off('mouse:move');

      }
      connecting = false;
      if (connectingLine) {
        canvas.remove(connectingLine);
        connectingLine = null;
        canvas.requestRenderAll();
      }
    }
    function getConnectionPositions(component) {
      let positions = [];
      switch (component.positionOfRottaion) {
        case 0:
          positions.push({ x: component.left + 45, y: component.top });
          positions.push({ x: component.left - 45, y: component.top });
          break;
        case 1:
          positions.push({ x: component.left, y: component.top - 45 });
          positions.push({ x: component.left, y: component.top + 45 });
          break;
        case 2:
          positions.push({ x: component.left - 45, y: component.top });
          positions.push({ x: component.left + 45, y: component.top });
          break;
        case 3:
          positions.push({ x: component.left, y: component.top + 45 });
          positions.push({ x: component.left, y: component.top - 45 });
          break;
      }
      return positions;
    }
    function updateConnectionPositions(component) {
      const posX = component.connectionPositions[1];
      const posY = component.connectionPositions[2];

      component.lines1.forEach((line, index) => {
        if (line.connectedFrom === "plus") {
          line.set({
            x1: component.left + posX,
            y1: component.top + posY,
          });
        } else {
          line.set({
            x1: component.left - posX,
            y1: component.top - posY,
          });
        }
        line.setCoords();
      });
      component.lines2.forEach((line, index) => {
        if (line.connectedTo === "plus") {
          line.set({
            x2: component.left + posX,
            y2: component.top + posY,
          });
        } else {
          line.set({
            x2: component.left - posX,
            y2: component.top - posY,
          });
        }
        line.setCoords();
      });

      canvas.requestRenderAll();
    }
    /*
     //https://stackoverflow.com/questions/21931271/how-to-enable-responsive-design-for-fabric-js
    function scaleCanvas() {
      const outerCanvasContainer = document.getElementById('fabric-canvas-container');
    
      const ratio          = canvas.getWidth() / canvas.getHeight();
      const containerWidth = outerCanvasContainer.clientWidth;
      const scale          = containerWidth / canvas.getWidth();
      const zoom           = canvas.getZoom() * scale;
    
      canvas.setDimensions({width: containerWidth, height: containerWidth / ratio});
      canvas.setViewportTransform([zoom, 0, 0, zoom, 0, 0]);
      canvas.calcOffset();
      canvas.requestRenderAll();
    }
    window.addEventListener('resize', scaleCanvas, false);
    scaleCanvas();
    */

    const DESIGN_WIDTH = 1400;
    const DESIGN_HEIGHT = 1000;

    function resizeCanvas() {
      // 1. Measure 'main' instead of the canvas container. 
      // Main is controlled by flexbox, so it never lies about the screen size!
      const mainElement = document.querySelector('main');

      const availableWidth = mainElement.clientWidth;
      const availableHeight = mainElement.clientHeight;

      // 2. Calculate the scale for both directions
      const scaleX = availableWidth / DESIGN_WIDTH;
      const scaleY = availableHeight / DESIGN_HEIGHT;

      // 3. Pick the SMALLER scale. This ensures it never overflows the bottom OR the sides.
      let scaleMultiplier = Math.min(scaleX, scaleY);

      // Optional: Stop it from zooming in massively on huge screens
      if (scaleMultiplier > 1) {
        scaleMultiplier = 1;
      }

      // 4. Set the physical size of the canvas element
      canvas.setDimensions({
        width: DESIGN_WIDTH * scaleMultiplier,
        height: DESIGN_HEIGHT * scaleMultiplier
      });

      // 5. Tell Fabric to visually shrink everything inside
      canvas.setZoom(scaleMultiplier);

      // 6. Recalculate mouse coordinates
      canvas.calcOffset();
      canvas.requestRenderAll();
    }

    // Ensure the HTML is fully loaded before we try to measure <main>
    window.addEventListener('load', () => {
      // Call it immediately on load
      resizeCanvas();

      // Sometimes the browser needs a split-second to finish drawing the flexbox layout.
      // This tiny timeout guarantees it measures the perfect final size.
      setTimeout(resizeCanvas, 50);
    });

    window.addEventListener('resize', resizeCanvas);



    // var bulb = addComponent('./images/light_bulb.png', 'Light Bulb');
    // var resistor = addComponent('./images/resistor.png', 'Resistor');
    // var source = addComponent('./images/source.png', 'Source');
    // var source2 = addComponent('./images/source.png', 'Source');

  </script>
</body>

</html>