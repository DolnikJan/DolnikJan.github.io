<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Circuit Maker</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: Arial, sans-serif;
    height: 100vh;
    overflow: hidden;
  }

  .container {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  header {
    background-color: #333;
    color: white;
    padding: 15px;
    text-align: center;
    flex-shrink: 0;
  }

  .main-content {
    display: flex;
    flex: 1;
    min-height: 0;
  }

  .sidebar {
    background-color: #f9f9f9;
    border-right: 1px solid #ddd;
    padding: 15px;
    width: 150px;
    overflow-y: auto;
    flex-shrink: 0;
  }

  .sidebar h2 {
    margin-top: 0;
    color: #333;
    font-size: 14px;
  }

  .sidebar button {
    display: block;
    width: 100%;
    padding: 10px;
    margin-bottom: 10px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
  }

  .sidebar button:hover {
    background-color: #0056b3;
  }

  main {
    flex: 1;
    overflow: hidden;
    display: flex;
  }

  .fabric-canvas-container {
    width: 100%;
    height: 100%;
    position: relative;
    touch-action: none;
  }

  #canvas {
    display: block;
  }

  @media (max-width: 768px) {
    .main-content {
      flex-direction: column;
    }

    .sidebar {
      width: 100%;
      border-right: none;
      border-bottom: 1px solid #ddd;
      max-height: 25vh;
    }

    main {
      flex: 1;
      min-height: 0;
    }
  }
</style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Circuit Maker</h1>
    </header>
    <div class="main-content">
      <aside class="sidebar">
        <h2>Components</h2>
        <button onclick="addComponent('./images/light_bulb.png', 'Light Bulb')">Add Light Bulb</button>
        <button onclick="addComponent('./images/resistor.png', 'Resistor')">Add Resistor</button>
        <button onclick="addComponent('./images/source.png', 'Source')">Add Source</button>
      </aside>
      <main>
        <div class="fabric-canvas-container" id="fabric-canvas-container">
          <canvas id="canvas" width="1400" height="1000"></canvas>
        </div>
      </main>
    </div>
  </div>

  

  <script src="https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"></script>
  <script>

    let counter = 0;
    let connecting = false;
    let connectingLine = null;
    let connectingfrom = null;
    let connectingto = null;
    let allLines = [];
    let selectedComponent = null;
    let bottom = 0;
    const GRID_SIZE = 100;

    const GRID_OFFSET_X = 200;
    const GRID_OFFSET_Y = 0;
    const GRID_WIDTH = 9;
    const GRID_HEIGHT = 9;
    const CANVAS_WIDTH = GRID_SIZE * GRID_WIDTH + GRID_OFFSET_X * 2;
    const CANVAS_HEIGHT = GRID_SIZE * GRID_HEIGHT + GRID_OFFSET_Y * 2;
    const GRID_ARRAY_OFFSET_X = 3;
    const GRID_ARRAY_OFFSET_Y = 1;
    const DESIGN_WIDTH = 1400;
    const DESIGN_HEIGHT = 1000;



    const canvasGrid = [];
    for (let i = 0; i < GRID_HEIGHT; i += 1) {
      canvasGrid.push(new Array(GRID_WIDTH).fill(null));
    }
    canvasGrid.forEach(row => {
      console.log(row);
    });






    function setUpImage(img) {
      let color = [Math.random() * 256, Math.random() * 256, Math.random() * 256];

      img.set({
        left: 50,
        dirty: true,
        scaleX: 0.4,
        scaleY: 0.4,
        originX: 'center',
        originY: 'center',
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        id: counter,
        connectionPositions: [0, 45, 0],
        positionOfRotation: 0,
        lines1: [],
        lines2: [],
        lineColor: color,
        gridPositionX: null,
        gridPositionY: null,
        startX: null,
        startY: null,

      });
      counter++;
      canvas.moveObjectTo(img, bottom);
      switch (img.name) {
        case 'Light Bulb':
          img.top = 150;
          break;
        case 'Resistor':
          img.top = 250;
          break;
        case 'Source':
          img.top = 350;
          break;
        case 'Switch':
          img.top = 450;
          break;
      }
      img.on('mousedown', function (options) {
        img.startX = img.gridPositionX;
        img.startY = img.gridPositionY;
      });
      img.on('moving', function (options) {
        hideButtons();
        //https://jsfiddle.net/fabricjs/S9sLu
        
        if (img.left > GRID_OFFSET_X && img.left < DESIGN_WIDTH - GRID_OFFSET_X && img.top > GRID_OFFSET_Y && img.top < DESIGN_HEIGHT - GRID_OFFSET_Y) {
          //console.log("left:" + Math.round(img.left / grid) + " top:" + Math.round(img.top / grid));

          /*img.set({
            left: Math.round(img.left / GRID_SIZE) * GRID_SIZE,
            top: Math.round(img.top / GRID_SIZE) * GRID_SIZE,
          });*/
          let gridX = Math.round(img.left / GRID_SIZE) - GRID_ARRAY_OFFSET_X;
          let gridY = Math.round(img.top / GRID_SIZE) - GRID_ARRAY_OFFSET_Y;
          if (gridY >= 0 && gridY < GRID_HEIGHT && gridX >= 0 && gridX < GRID_WIDTH && (canvasGrid[gridY][gridX] == null || canvasGrid[gridY][gridX] === img)) {
            // console.log("moving to grid");


            img.left = Math.round(img.left / GRID_SIZE) * GRID_SIZE;
            img.top = Math.round(img.top / GRID_SIZE) * GRID_SIZE;
            img.gridPositionX = gridX;
            img.gridPositionY = gridY;
            img.setCoords();


          }

        }
        updateConnectionPositions(img);
      });

      img.on('mouseup', function () {
        
        if (img.startX != null && img.startY != null) {
          canvasGrid[img.startY][img.startX] = null;
        }

        if (img.left > DESIGN_WIDTH - GRID_OFFSET_X) {

          deleteComponent(img);
          return;
        } else if (img.left < GRID_OFFSET_X) {

          img.gridPositionX = null;
          img.gridPositionY = null;
          img.lines1.forEach((line, index) => {
            disconnectComponents(line);
          });
          img.lines2.forEach((line, index) => {
            disconnectComponents(line);
          });
          return;
        }

        if (img.gridPositionX != null && img.gridPositionY != null) {
          canvasGrid[img.gridPositionY][img.gridPositionX] = img;
        }

        img.set({
          left: (img.gridPositionX+GRID_ARRAY_OFFSET_X) * GRID_SIZE,
          top: (img.gridPositionY + GRID_ARRAY_OFFSET_Y) * GRID_SIZE,
        });
        img.setCoords();
        canvas.requestRenderAll();
        //console.log('Image mouse up:', img);
        selectedComponent = img;
        showButtons(img);


      });
      img.on('selected', function (options) {
        if (!connecting) {
        } else {
          let pointer = canvas.getPointer(options.e);
          setConnectingTo(img, pointer);
          stopConnecting(img);
        }
      });
      canvas.add(img);

    }

    const canvas = new fabric.Canvas('canvas');
    canvas.on('mouse:down', function (options) {
      if (options.target == null) {
        hideButtons();
        
        if (connecting) {
          stopConnecting(null);
        }
      } else {
        console.log('Clicked on object:', options.target);
      }
    });
    canvas.on('mouse:up', function (options) {
      console.log('Canvas mouse up:');
      if (connecting) {
        console.log('Currently connecting, checking if we clicked on a valid target...');
        let pointer = canvas.getPointer(options.e);
        let x = Math.round(pointer.x / GRID_SIZE)-GRID_ARRAY_OFFSET_X;
        let y = Math.round(pointer.y / GRID_SIZE) - GRID_ARRAY_OFFSET_Y;
        if(canvasGrid[y][x] == null){
          console.log('Clicked on empty grid position:', x, y);
         //stopConnecting(null);
        } else {
          console.log('Clicked on grid position with component:', canvasGrid[y][x]);
          setConnectingTo(canvasGrid[y][x], pointer);
          stopConnecting(canvasGrid[y][x]);
        }
       /* canvas.getObjects().forEach(obj => {
          if (obj.name && obj!==selectedComponent) {
            if(obj.containsPoint(pointer)){
              if(connecting){
                console.log('Clicked on object while connecting:', obj);
                stopConnecting(obj);
                connecting = false;
              }
              
            }
           
          }
            
        });*/
        
        
      }
        
    });
    canvas.backgroundColor = 'rgb(48, 87, 225)';
    canvas.preserveObjectStacking = true;
   

    canvas.selection = false;
    let offset=GRID_SIZE/2;
    for (let i = 1; i < 11; i++) {
      const lineY = new fabric.Line([GRID_OFFSET_X, i * GRID_SIZE - offset, DESIGN_WIDTH-GRID_OFFSET_X, i * GRID_SIZE - offset], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',
        hasControls: false,
        hasBorders: false,
        lockRotation: true,

      });
      
      

      const lineX = new fabric.Line([i * GRID_SIZE - offset+GRID_OFFSET_X, GRID_OFFSET_Y, i * GRID_SIZE - offset+GRID_OFFSET_X, DESIGN_HEIGHT], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
      });
      canvas.add(lineX);
      canvas.add(lineY);
      canvas.sendObjectToBack(lineX);
      canvas.sendObjectToBack(lineY);
      bottom+=2;

     
    }
  
          canvas.requestRenderAll();

     const rectangle = new fabric.Rect({
      left: 0,
      top: 0,
      fill: 'white',
      width: GRID_OFFSET_X,
      height: DESIGN_HEIGHT,
      selectable: false,
      evented: false,
    });
    console.log(rectangle);
    const removeComponentRectangle = new fabric.Rect({
      left: DESIGN_WIDTH-GRID_OFFSET_X,
      top: GRID_OFFSET_Y,
      fill: 'red',
      width: GRID_OFFSET_X,
      height: DESIGN_HEIGHT - GRID_OFFSET_Y,
      selectable: false,
      evented: false,
    });
    
    canvas.add(rectangle);
    canvas.add(removeComponentRectangle);
    canvas.moveObjectTo(rectangle, bottom);
    canvas.moveObjectTo(removeComponentRectangle, bottom);
   
    canvas.renderAll();

    var text = new fabric.Text('hiÅ¯akjfghlak', {
      left: 150,
      top: 100,
      fontSize: 150,
      fill: 'black',
      originX: 'center',
      originY: 'center',
      width: 1000,
      scaleX: 0.2,
      scaleY: 0.2,
    });
    var text_holder;
    fabric.Image.fromURL('./images/text_holder.png').then((img) => {
      img.set({
        left: 100,
        top: 100,
        originX: 'center',
        originY: 'center',
        scaleX: 0.2,
        scaleY: 0.2,
      });

      canvas.add(img);
      canvas.moveObjectTo(img, bottom);
  
      canvas.moveObjectTo(text, bottom);
      

      text_holder = img;
      img.set('visible', false);
      return img;
    });
    var plus_button;
    fabric.Image.fromURL('./images/plus_button.png').then((img) => {
      img.set({
        left: 150,
        top: 150,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      plus_button = img;
      canvas.add(plus_button);
      buttonSetUp(plus_button);
      plus_button.on('mousedown', function (options) {
        connectingfrom = "plus";
        hideButtons();
        startConnecting(selectedComponent);
      });
      return img;
    });
    var minus_button;
    fabric.Image.fromURL('./images/minus_button.png').then((img) => {
      img.set({
        left: 150,
        top: 200,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      minus_button = img;
      canvas.add(minus_button);
      buttonSetUp(minus_button);
      minus_button.on('mousedown', function (options) {
        connectingfrom = "minus";
        hideButtons();
        startConnecting(selectedComponent);
      });
      return img;
    });
    var delete_button;
    fabric.Image.fromURL('./images/delete_button.png').then((img) => {
      img.set({
        left: 150,
        top: 250,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      delete_button = img;
      canvas.add(delete_button);
      buttonSetUp(delete_button);
      delete_button.on('mouseup', function (options) {
        deleteComponent(selectedComponent);
      });
      return img;
    });
    var rotate_button;
    fabric.Image.fromURL('./images/rotate_button.png').then((img) => {
      img.set({
        left: 150,
        top: 300,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      rotate_button = img;
      canvas.add(rotate_button);
      buttonSetUp(rotate_button);
      rotate_button.on('mousedown', function (options) {
        rotateComponent(selectedComponent);
      });
      return img;
    });

    canvas.add(text);

    buttonSetUp(text);


    function showButtons(image) {
      selectedComponent = image;
      text.set({
        text: image.name,
        left: image.left,
        top: image.top - 70,
        stroke: 'black',
        originX: 'center',
        originY: 'center',
      });

      text_holder.set({
        left: image.left,
        top: image.top - 70,
        originX: 'center',
        originY: 'center',
      });

      plus_button.set({

        left: image.left + 80,
        top: image.top,
      });

      minus_button.set({
        left: image.left - 80,
        top: image.top, // Position text above the image


      });
      delete_button.set({
        left: image.left - 40,
        top: image.top + 80, // Position text above the image


      });
      rotate_button.set({
        left: image.left + 40,
        top: image.top + 80, // Position text above the image


      });
      text.set('visible', true);
      text_holder.set('visible', true);
      plus_button.set('visible', true);
      minus_button.set('visible', true);
      delete_button.set('visible', true);
      rotate_button.set('visible', true);
      text.setCoords();
      plus_button.setCoords();
      minus_button.setCoords();
      delete_button.setCoords();
      rotate_button.setCoords();


      canvas.bringObjectToFront(text_holder);
      canvas.bringObjectToFront(text);
      canvas.bringObjectToFront(plus_button);
      canvas.bringObjectToFront(minus_button);
      canvas.bringObjectToFront(delete_button);
      canvas.bringObjectToFront(rotate_button);
      /*
      text.set('dirty', true);
      text_holder.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);
      */
      canvas.requestRenderAll();
    }
    function hideButtons() {
      text.set('visible', false);
      text_holder.set('visible', false);
      plus_button.set('visible', false);
      minus_button.set('visible', false);
      delete_button.set('visible', false);
      rotate_button.set('visible', false);

      text.set('dirty', true);
     
     /* text_holder.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);
      */

      canvas.requestRenderAll();
    }
    function buttonSetUp(button) {
      button.set({
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        selectable: false,
        lockMovementX: true,
        lockMovementY: true,
        dirty: true,
        fill: 'black',
        hoverCursor: 'pointer',
        visible:false,
      });

    }
    function addComponent(url, name) {
      fabric.Image.fromURL(url).then((img) => {
        img.set({
          name: name,
        });
        setUpImage(img);

        //img.visible = false;
        return img;
      });
    }
    function deleteComponent(component) {
       if (component.gridPositionY != null && component.gridPositionX != null) {
        canvasGrid[component.gridPositionY][component.gridPositionX] = null;
      }
      canvas.remove(component);
      canvas.remove(selectedComponent);
      selectedComponent = null;
      
      for (let i = component.lines1.length - 1; i >= 0; i--) {
       disconnectComponents(component.lines1[i]);
      }
      for (let i = component.lines2.length - 1; i >= 0; i--) {
      disconnectComponents(component.lines2[i]);
      }
     
      
            hideButtons();
            canvas.requestRenderAll();

    }
    function rotateComponent(component) {
      console.log('Rotating component:', component);
      component.rotate((component.angle + 90) % 360);
      component.set('dirty', true);
      component.set({
        positionOfRotation: component.positionOfRotation + 1,
      });
      if (component.positionOfRotation === 4) {
        component.positionOfRotation = 0;
      }
      switch (component.connectionPositions[0]) {
        case 0:
          component.connectionPositions = [1, 0, 45];
          break;
        case 1:
          component.connectionPositions = [2, -45, 0];
          break;
        case 2:
          component.connectionPositions = [3, 0, -45];
          break;
        case 3:
          component.connectionPositions = [0, 45, 0];
          break;
      }
      updateConnectionPositions(component);


      canvas.requestRenderAll();
    }
    function connectComponents(component1, component2) {

      let positions1 = getConnectionPositions(component1);
      let positions2 = getConnectionPositions(component2);
      let  index1 = 0;
      let index2 = 0;
        if(connectingfrom === "minus"){
          index1 = 1;
        }
        if(connectingto === "minus"){
          index2 = 1;
        }

      let strokeColor = component1.lineColor;
      const line = new fabric.Line([positions1[index1].x, positions1[index1].y, positions2[index2].x, positions2[index2].y], {
        stroke: `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`,
        strokeWidth: 4,
        selectable: false,
        positionLeft1: positions1[index1].x,
        positionTop1: positions1[index1].y,
        positionLeft2: positions2[index2].x,
        positionTop2: positions2[index2].y,
        connectedFrom: connectingfrom,
        connectedFromComponent: component1,
        connectedTo: connectingto,
        connectedToComponent: component2,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });
      connectingfrom = null;
      connectingto = null;
      component1.lines1.push(line);
      component2.lines2.push(line);
      allLines.push(line);
      canvas.add(line);

      canvas.moveObjectTo(line, bottom);
      canvas.requestRenderAll();
    }
    function disconnectComponents(line) {
      line.connectedFromComponent.lines1.splice(line.connectedFromComponent.lines1.indexOf(line), 1);
      line.connectedToComponent.lines2.splice(line.connectedToComponent.lines2.indexOf(line), 1);
      allLines.splice(allLines.indexOf(line), 1);
      canvas.remove(line);
      canvas.requestRenderAll();
    }
    function startConnecting(component) {
      connecting = true;
      selectedComponent = component;
      strokeColor = component.lineColor;
       let positions = getConnectionPositions(component);
       let index = 0;
       if(connectingfrom === "minus"){
        index = 1;
       }
      connectingLine = new fabric.Line([positions[index].x, positions[index].y, positions[index].x, positions[index].y], {
        stroke: `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`,
        strokeWidth: 4,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });
      canvas.add(connectingLine);
      canvas.on('mouse:move', function (options) {
        if (connecting) {
          let pointer = canvas.getPointer(options.e);
          connectingLine.set({ x2: pointer.x, y2: pointer.y });
          canvas.requestRenderAll();
        }
      });

    }
    function stopConnecting(component) {


      if (component != null) {
        connectComponents(selectedComponent, component);
        canvas.off('mouse:move');

      }
      connecting = false;
      if (connectingLine) {
        canvas.remove(connectingLine);
        connectingLine = null;
        canvas.requestRenderAll();
      }
    }
    function getConnectionPositions(component) {
      let positions = [];
      

      switch (component.positionOfRotation) {
        case 0:
          positions.push({ x: component.left + 45 , y: component.top });
          positions.push({ x: component.left - 45 , y: component.top });
          break;
        case 1:
          positions.push({ x: component.left, y: component.top + 45});
          positions.push({ x: component.left, y: component.top - 45});
          break;
        case 2:
          positions.push({ x: component.left - 45, y: component.top });
          positions.push({ x: component.left + 45, y: component.top });
          break;
        case 3:
          positions.push({ x: component.left, y: component.top - 45 });
          positions.push({ x: component.left, y: component.top + 45 });
          break;
      }
      return positions;
    }
    function updateConnectionPositions(component) {
      let positions = getConnectionPositions(component);
      
      //const posX = component.connectionPositions[1];
      //const posY = component.connectionPositions[2];

      component.lines1.forEach((line) => {
        if (line.connectedFrom === "plus") {
          line.set({
            x1: positions[0].x,
            y1: positions[0].y,
          });
        } else {
          line.set({
            x1: positions[1].x,
            y1: positions[1].y,
          });
        }
        line.setCoords();
      });
      component.lines2.forEach((line, index) => {
        if (line.connectedTo === "plus") {
          line.set({
            x2: positions[0].x,
            y2: positions[0].y,
          });
        } else {
          line.set({
            x2: positions[1].x,
            y2: positions[1].y,
          });
        }
        line.setCoords();
      });

      canvas.requestRenderAll();
    }
    function setConnectingTo(component, pointer) {
      let positions = getConnectionPositions(component);
      let distanceToPlus = Math.hypot(pointer.x - positions[0].x, pointer.y - positions[0].y);
      let distanceToMinus = Math.hypot(pointer.x - positions[1].x, pointer.y - positions[1].y);
      if (distanceToPlus < distanceToMinus) {
        connectingto = "plus";
      } else {
        connectingto = "minus";
      }
    }
    /*
     //https://stackoverflow.com/questions/21931271/how-to-enable-responsive-design-for-fabric-js
    function scaleCanvas() {
      const outerCanvasContainer = document.getElementById('fabric-canvas-container');
    
      const ratio          = canvas.getWidth() / canvas.getHeight();
      const containerWidth = outerCanvasContainer.clientWidth;
      const scale          = containerWidth / canvas.getWidth();
      const zoom           = canvas.getZoom() * scale;
    
      canvas.setDimensions({width: containerWidth, height: containerWidth / ratio});
      canvas.setViewportTransform([zoom, 0, 0, zoom, 0, 0]);
      canvas.calcOffset();
      canvas.requestRenderAll();
    }
    window.addEventListener('resize', scaleCanvas, false);
    scaleCanvas();
    */

    

    function resizeCanvas() {
      // 1. Measure 'main' instead of the canvas container. 
      // Main is controlled by flexbox, so it never lies about the screen size!
      const mainElement = document.querySelector('main');

      const availableWidth = mainElement.clientWidth;
      const availableHeight = mainElement.clientHeight;

      // 2. Calculate the scale for both directions
      const scaleX = availableWidth / DESIGN_WIDTH;
      const scaleY = availableHeight / DESIGN_HEIGHT;

      // 3. Pick the SMALLER scale. This ensures it never overflows the bottom OR the sides.
      let scaleMultiplier = Math.min(scaleX, scaleY);

      // Optional: Stop it from zooming in massively on huge screens
      if (scaleMultiplier > 1) {
        scaleMultiplier = 1;
      }

      // 4. Set the physical size of the canvas element
      canvas.setDimensions({
        width: DESIGN_WIDTH * scaleMultiplier,
        height: DESIGN_HEIGHT * scaleMultiplier
      });

      // 5. Tell Fabric to visually shrink everything inside
      canvas.setZoom(scaleMultiplier);

      // 6. Recalculate mouse coordinates
      canvas.calcOffset();
      canvas.requestRenderAll();
    }

    // Ensure the HTML is fully loaded before we try to measure <main>
    window.addEventListener('load', () => {
      // Call it immediately on load
      resizeCanvas();

      // Sometimes the browser needs a split-second to finish drawing the flexbox layout.
      // This tiny timeout guarantees it measures the perfect final size.
      setTimeout(resizeCanvas, 50);
    });

    window.addEventListener('resize', resizeCanvas);



    // var bulb = addComponent('./images/light_bulb.png', 'Light Bulb');
    // var resistor = addComponent('./images/resistor.png', 'Resistor');
    // var source = addComponent('./images/source.png', 'Source');
    // var source2 = addComponent('./images/source.png', 'Source');

  </script>
</body>

</html>