<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circuit Maker</title>

</head>

<body>
  <div class="container">
    <header>
      <h1>Circuit Maker</h1>
    </header>
    <div class="main-content">
      <aside class="sidebar">
        <h2>Components</h2>
        <button onclick="addComponent('./images/light_bulb.png', 'Light Bulb')">Add Light Bulb</button>
        <button onclick="addComponent('./images/resistor.png', 'Resistor')">Add Resistor</button>
        <button onclick="addComponent('./images/source.png', 'Source')">Add Source</button>
      </aside>
      <main>
        <canvas id="canvas" width="1400" height="1000"></canvas>
      </main>
    </div>
  </div>

  <style>
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      background-color: #333;
      color: white;
      padding: 20px;
      text-align: center;
    }

    .main-content {
      display: flex;
      flex: 1;
    }

    .sidebar {
      background-color: #f9f9f9;
      border-right: 1px solid #ddd;
      padding: 20px;
      width: 200px;
      overflow-y: auto;
    }

    .sidebar h2 {
      margin-top: 0;
      color: #333;
    }

    .sidebar button {
      display: block;
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .sidebar button:hover {
      background-color: #0056b3;
    }

    main {
      flex: 1;
      overflow: hidden;
    }

    #canvas {
      display: block;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/fabric@6.4.3/dist/index.js"></script>
  <script>
    let counter = 0;
    let connecting = false;
    let connectingLine = null;
    let connectingfrom = null;
    let connectingto = null;
    let allLines = [];
    let selectedComponent = null;
    let bottom =0;

    function setUpImage(img) {
          let color = [Math.random() * 256, Math.random() * 256, Math.random() * 256];

      img.set({
        left:50,
        dirty: true,
        scaleX: 0.4,
        scaleY: 0.4,
        originX: 'center',
        originY: 'center',
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        id: counter,
        connectionPositions: [0,45,0],
        positionOfRottaion: 0,
        lines1: [],
        lines2: [],
        lineColor: color,

      });
      switch(img.name){
        case 'Light Bulb':
          img.top = 150;
          break;
        case 'Resistor':
          img.top = 250;
          break;
        case 'Source':
          img.top = 350;
          break;
        case 'Switch':
          img.top = 450;
          break;
      }
      
      img.on('moving', function (options) {
        hideButtons();
        //https://jsfiddle.net/fabricjs/S9sLu
        if(img.left>200 && img.left<1200 && img.top>0 && img.top<1000){
          
        let grid = 100;
        img.set({
          left: Math.round(img.left / grid) * grid,
          top: Math.round(img.top / grid) * grid,
        });
        
        }
        updateConnectionPositions(img);
      });

      img.on('mouseup', function () {
        if(img.left>1200){
          deleteComponent(img);
          return;
        }
        console.log('Image mouse up:', img);
        selectedComponent = img;
        showButtons(img);
        
        
      });
      img.on('selected', function (options) {
        if (!connecting) {
       /* console.log('Image selected:', img);
        selectedComponent = img;
        showButtons(img);*/
        
        } else {
          let pointer = canvas.getPointer(options.e);
          console.log('Pointer left:', pointer.x, 'Pointer top:', pointer.y);
          let pointerPosition, componentPosition;
          if(img.connectionPositions[0] %2==1){
            console.log('Vertical component selected');
             pointerPosition = pointer.y;
            componentPosition = img.top;
          }else{
            console.log('Horizontal component selected');
            pointerPosition = pointer.x;
            componentPosition = img.left;
          }
          if(img.connectionPositions[0] >1){
            pointerPosition *=-1;
            componentPosition *=-1;
          }
          
          if(pointerPosition>componentPosition){
            connectingto = "plus";
          }else{
            connectingto = "minus";
          }
          stopConnecting(img);
        }
      });
      canvas.add(img);
     
    }

    const canvas = new fabric.Canvas('canvas');
    canvas.on('mouse:down', function (options) {
      //console.log('Canvas mouse down:', options);
      if (options.target == null) {
        hideButtons();
        //console.log('Clicked on empty canvas area, hiding buttons.');
        if(connecting){
          stopConnecting(null);
        }
      }else{
       // console.log('Clicked on object:', options.target);
      }
    });
    canvas.backgroundColor = 'rgb(48, 87, 225)';
    canvas.preserveObjectStacking = true;
    const rectangle = new fabric.Rect({
      left: 0,
      top: 0,
      fill: 'white',
      width: 200,
      height: 1000,
      selectable: false,
      evented: false,
    });
    const removeComponentRectangle = new fabric.Rect({
      left: 1200,
      top: 0,
      fill: 'red',
      width: 200,
      height: 1000,
      selectable: false,
      evented: false,
    });
    canvas.add(rectangle);
    canvas.add(removeComponentRectangle);
    canvas.moveObjectTo(rectangle,bottom);
    bottom++;
    canvas.moveObjectTo(removeComponentRectangle,bottom);
    bottom++;
    canvas.renderAll();

    canvas.selection = false;
    for (let i = 1; i < 13; i++) {
      const lineX = new fabric.Line([200, i * 100 - 50, 1200, i * 100 - 50], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',


      });
      lineX.set({
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
      });

      const lineY = new fabric.Line([i * 100 - 50, 0, i * 100 - 50, 1000], {
        stroke: 'white',
        strokeWidth: 1,
        selectable: false,
        hoverCursor: 'default',
      });
      canvas.add(lineX);
      canvas.add(lineY);
      canvas.moveObjectTo(lineX,bottom);
      bottom++;
      canvas.moveObjectTo(lineY,bottom);
      bottom++;
     
      canvas.requestRenderAll();
     
    }
    
    var text = new fabric.Text('', {
      left: 150,
      top: 100,
      fontSize: 150,
      fill: 'white',
      originX: 'center',
      originY: 'center',
      width: 1000,
      scaleX: 0.2,
      scaleY: 0.2,
    });
    var text_holder;
    fabric.Image.fromURL('./images/text_holder.png').then((img) => {
      img.set({
        left: 100,
        top: 100,
        originX: 'center',
        originY: 'center',
        scaleX: 0.2,
        scaleY: 0.2,
      });
      
      canvas.add(img);
      canvas.moveObjectTo(img,bottom);
      bottom++;
      canvas.moveObjectTo(text,bottom);
      bottom++;
      text_holder = img; 
      img.set('visible', false);
      return img;
    });
    var plus_button;
    fabric.Image.fromURL('./images/plus_button.png').then((img) => {
      img.set({
        left: 150,
        top: 150,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      plus_button = img;
      canvas.add(plus_button);
      buttonSetUp(plus_button);
      plus_button.on('mousedown', function (options) {
        connectingfrom = "plus";
        hideButtons();
        startConnecting(selectedComponent);
      });
      return img;
    });
    var minus_button;
    fabric.Image.fromURL('./images/minus_button.png').then((img) => {
      img.set({
        left: 150,
        top: 200,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      minus_button = img;
      canvas.add(minus_button);
      buttonSetUp(minus_button);
      minus_button.on('mousedown', function (options) {
        connectingfrom = "minus";
        hideButtons();
        startConnecting(selectedComponent);
      });
      return img;
    });
    var delete_button;
    fabric.Image.fromURL('./images/delete_button.png').then((img) => {
      img.set({
        left: 150,
        top: 250,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      delete_button = img;
      canvas.add(delete_button);
      buttonSetUp(delete_button);
      delete_button.on('mousedown', function (options) {
        deleteComponent(selectedComponent);
      });
      return img;
    });
    var rotate_button;
    fabric.Image.fromURL('./images/rotate_button.png').then((img) => {
      img.set({
        left: 150,
        top: 300,
        originX: 'center',
        originY: 'center',
        scaleX: 0.15,
        scaleY: 0.15,
      });
      rotate_button = img;
      canvas.add(rotate_button);
      buttonSetUp(rotate_button);
      rotate_button.on('mousedown', function (options) {
        rotateComponent(selectedComponent);
      });
      return img;
    });
   
    canvas.add(text);
    
    buttonSetUp(text);
 

    function showButtons(image) {
      selectedComponent = image;
      text.set({
        text: image.name,
        left: image.left,
        top: image.top-70,
        originX: 'center',
        originY: 'center',
      });
      console.log("showinf textholdwer at", image.left, image.top-70);
      console.log("text holder at", text_holder.left, text_holder.top);
      text_holder.set({
        left: image.left,
        top: image.top - 70,
        originX: 'center',
        originY: 'center',
      });
      console.log(text_holder)
      console.log("text holdwer at", text_holder.left, text_holder.top);

      plus_button.set({
      
        left: image.left + 80,
        top: image.top,
      });

      minus_button.set({
        left: image.left - 80,
        top: image.top, // Position text above the image
        

      });
      delete_button.set({
        left: image.left-40,
        top: image.top + 80, // Position text above the image
       

      });
      rotate_button.set({
        left: image.left+40,
        top: image.top + 80, // Position text above the image
        

      });
      text.set('visible', true);
      text_holder.set('visible', true);
      plus_button.set('visible', true);
      minus_button.set('visible', true);
      delete_button.set('visible', true);
      rotate_button.set('visible', true);
      text.setCoords();
      plus_button.setCoords();
      minus_button.setCoords();
      delete_button.setCoords();
      rotate_button.setCoords();

      canvas.bringObjectToFront(text);
      canvas.bringObjectToFront(text_holder);
      canvas.bringObjectToFront(plus_button);
      canvas.bringObjectToFront(minus_button);
      canvas.bringObjectToFront(delete_button);
      canvas.bringObjectToFront(rotate_button);

      text.set('dirty', true);
      text_holder.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);
      canvas.requestRenderAll();
    }
    function hideButtons() {
      text.set('visible', false);
      text_holder.set('visible', false);
      plus_button.set('visible', false);
      minus_button.set('visible', false);
      delete_button.set('visible', false);
      rotate_button.set('visible', false);

      text.set('dirty', true);
      text_holder.set('dirty', true);
      plus_button.set('dirty', true);
      minus_button.set('dirty', true);
      delete_button.set('dirty', true);
      rotate_button.set('dirty', true);

      text.set({
        left: -1000,
        top: -100,
      });
      plus_button.set({
        left: -1000,
        top: -100,
      });
      minus_button.set({
        left: -1000,
        top: -100,
      });
      delete_button.set({
        left: -1000,
        top: -100,
      });
      rotate_button.set({
        left: -1000,
        top: -100,
      });

      canvas.requestRenderAll();
    }
    function buttonSetUp(button) {
      button.set({
        left: -1000,
        top: -100,
        hasControls: false,
        hasBorders: false,
        lockRotation: true,
        selectable: true,
        lockMovementX: true,
        lockMovementY: true,
        dirty: true,
        fill: 'red',
      });

    }
    function addComponent(url, name) {
      fabric.Image.fromURL(url).then((img) => {
        img.set({
          name: name,
        });
        setUpImage(img);
        
        //img.visible = false;
        return img;
      });
    }
    function deleteComponent(component) {
      for (let i = component.lines1.length - 1; i >= 0; i--) {
        disconnectComponents(component.lines1[i]);
      }
      for (let i = component.lines2.length - 1; i >= 0; i--) {
        disconnectComponents(component.lines2[i]);
      }
      
        canvas.remove(component);
        hideButtons();
      
    }
    function deleteLine(line) {
      canvas.remove(line);
      canvas.requestRenderAll();
    }
    function rotateComponent(component) {
      console.log('Rotating component:', component);
      component.rotate((component.angle + 90) % 360);
      component.set('dirty', true);
      component.set({
        positionOfRottaion: component.positionOfRottaion + 1,
      });
      if (component.positionOfRottaion === 4) {
        component.positionOfRottaion = 0;
      }
      switch (component.connectionPositions[0]) {
        case 0:
          component.connectionPositions = [1,0,45];
          break;
        case 1:
          component.connectionPositions = [2,-45,0];
          break;
        case 2:
          component.connectionPositions = [3,0,-45];
          break;
        case 3:
          component.connectionPositions = [0,45,0];
          break;
      }
      updateConnectionPositions(component);


      canvas.requestRenderAll();
    }
    function connectComponents(component1, component2) {
  
     let x1,y1,x2,y2;
     if(connectingfrom === "plus"){
        x1=component1.connectionPositions[1];
        y1=component1.connectionPositions[2];
      }else{
        x1=-component1.connectionPositions[1];
        y1=-component1.connectionPositions[2];
      }
      if(connectingto === "plus"){
        x2=component2.connectionPositions[1];
        y2=component2.connectionPositions[2];
      }else{
        x2=-component2.connectionPositions[1];
        y2=-component2.connectionPositions[2];
      }
      let strokeColor = component1.lineColor;
      const line = new fabric.Line([component1.left + x1, component1.top + y1, component2.left + x2, component2.top + y2], {
        stroke: `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`,
        strokeWidth: 4,
        selectable: false,
        positionLeft1:x1,
        positionTop1:y1,
        positionLeft2:x2,
        positionTop2:y2,
        connectedFrom: connectingfrom,
        connectedFromComponent: component1,
        connectedTo: connectingto,
        connectedToComponent: component2,

      });
      connectingfrom = null;
      connectingto = null;
      component1.lines1.push(line);
      component2.lines2.push(line);
      allLines.push(line);
      canvas.add(line);

      canvas.moveObjectTo(line,bottom);
      bottom++;
      canvas.requestRenderAll();
    }
    function disconnectComponents(line) {
      line.connectedFromComponent.lines1.splice(line.connectedFromComponent.lines1.indexOf(line), 1);
      line.connectedToComponent.lines2.splice(line.connectedToComponent.lines2.indexOf(line), 1);
      allLines.splice(allLines.indexOf(line), 1);
      canvas.remove(line);
      canvas.requestRenderAll();
    }
    function startConnecting(component) {
      connecting = true;
      selectedComponent = component;
      strokeColor = component.lineColor;
      let multiplier = 1;
      if(connectingfrom === "minus"){
        multiplier = -1;
      }
      connectingLine = new fabric.Line([component.left + component.connectionPositions[1]*multiplier, component.top + component.connectionPositions[2]*multiplier, component.left, component.top], {
        stroke: `rgb(${strokeColor[0]}, ${strokeColor[1]}, ${strokeColor[2]})`,
        strokeWidth: 4,
        selectable: false,
      });
      canvas.add(connectingLine);
      canvas.on('mouse:move', function (options) {
        if (connecting) {
          connectingLine.set({ x2: options.pointer.x, y2: options.pointer.y });
          canvas.requestRenderAll();
        }
      });

    }
    function stopConnecting(component) {

      
      if(component!=null){
      connectComponents(selectedComponent, component);
      canvas.off('mouse:move');
     
    }
    connecting = false;
     if (connectingLine) {
        canvas.remove(connectingLine);
        connectingLine = null;
        canvas.requestRenderAll();
      }
    }
    function getConnectionPositions(component) {
      let positions = [];
      switch (component.positionOfRottaion) {
        case 0:
          positions.push({ x: component.left + 45, y: component.top });
          positions.push({ x: component.left - 45, y: component.top });
          break;
        case 1:
          positions.push({ x: component.left, y: component.top - 45 });
          positions.push({ x: component.left, y: component.top + 45 });
          break;
        case 2:
          positions.push({ x: component.left - 45, y: component.top });
          positions.push({ x: component.left + 45, y: component.top });
          break;
        case 3:
          positions.push({ x: component.left, y: component.top + 45 });
          positions.push({ x: component.left, y: component.top - 45 });
          break;
      }
      return positions;
    }
    function updateConnectionPositions(component) {
    const posX = component.connectionPositions[1]; 
    const posY = component.connectionPositions[2]; 

    component.lines1.forEach((line, index) => {
      if(line.connectedFrom === "plus"){
        line.set({
          x1: component.left+ posX,
          y1: component.top + posY,
        });
      }else{
        line.set({
          x1: component.left - posX,
          y1: component.top - posY,
        });
      }
      line.setCoords();
    });
    component.lines2.forEach((line, index) => {
      if(line.connectedTo === "plus"){
        line.set({
          x2: component.left + posX,
          y2: component.top + posY,
        });
      }else{
        line.set({
          x2: component.left - posX,
          y2: component.top - posY,
        });
      }
      line.setCoords();
    });

    canvas.requestRenderAll();
}

    

    
   // var bulb = addComponent('./images/light_bulb.png', 'Light Bulb');
   // var resistor = addComponent('./images/resistor.png', 'Resistor');
   // var source = addComponent('./images/source.png', 'Source');
   // var source2 = addComponent('./images/source.png', 'Source');

  </script>
</body>

</html>